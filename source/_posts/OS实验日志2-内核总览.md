---
title: OS实验日志2-内核总览
date: 2023-05-02 11:00:51
tags:
---

# 内核总览

## 进入内核以及传递内存检测信息

之前loader已经为内核代码的加载做好了准备，因此我们需要在这里跳转到内核代码，并把之前loader中获得的硬件信息传递给内核

* 进入内核代码入口

    在上一章中，我们把kernel_entry强制转换成一个不会返回的、参数为boot_info_t * 的函数指针（在c和c++中，函数指针pf和*pf都表示对指向的函数进行调用）

        (void (*)(boot_info_t *))kernel_entry)(&boot_info);

    其中kernel_entry是elf文件解析出的32位入口地址

        uint32_t kernel_entry = reload_elf_file((uint8_t *)SYS_KERNEL_LOAD_ADDR);

    这个地址是我们在lds脚本指定的elf文件的内存加载位置

        . = 0x10000;
    
    之前loader中的代码编译成了bin文件，存放在内存地址xxx处，不会影响elf文件中的代码

        COMMAND ${OBJCOPY_TOOL} -O binary ${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/../../image/${PROJECT_NAME}.bin

    我们通过函数调用跳转到这个地址，而这个地址将会是elf文件代码区的第一个指令的地址，因此我们新建一个文件夹并指定gcc编译器将代码编译成 elf文件

        COMMAND ${OBJCOPY_TOOL} -S ${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/../../image/${PROJECT_NAME}.elf

    在汇编文件中 _start 标签的汇编代码是默认的程序入口，因此elf文件代码区的第一条指令将会是保护模式中函数_start的第一条指令，我们在_start函数中参数传递

* 参数传递

    在上一章中我们知道，初始化内核也需要内存信息，boot内存检测得到的的信息需要传递给内核

    在讨论如何传递参数前，我们先来看一下函数的栈结构

    ![avatar](/source/markdown_img/1/1.png)

    如图所示，从栈顶向栈底方向，依次保存着(可能会有的)寄存器现场、局部变量、调用者的ebp(栈基址指针，方便对栈操作)、返回地址、参数1、2、3(函数调用处地址)，而调用函数是通过eax寄存器(一般用来存放第一个参数)或将%eax压入栈中作为被调用函数的参数，我们利用这一点实现参数传递

    对于一个由地址强制转换成的函数，由于函数不会返回，因此不用保调用者寄存器现场，函数显然也没有局部变量，因此栈中应该保存着返回地址以及唯一一个参数 &boot_info（boot_info的地址），我们会在这个函数中再做一次跳转，跳转到c函数中处理(因为c更好处理后续操作)


    一个被call指令正常调用的函数，参数会通过寄存器或栈传递参数，对于即将调用的c函数，本函数_start又变为调用者函数，因此我们在call指令前手动将_start的栈顶指针%esp作为栈基址%ebp压入栈中，在此之前我们得先压入上一个%ebp，然后再将%esp值传给%ebp
    
        push %ebp
	    mov %esp, %ebp
    
    此时%esp+4，%esp距离参数boot_t相隔一个刚压入栈中的%ebp和返回地址，偏移量为8，这个%esp作为栈基址传入%ebp中覆盖掉上一个%ebp值。由于我们知道了参数在栈中相对于%ebp的偏移量，易知参数在栈中的位置为%ebp+0x8，我们把这个位置的值传递给%eax，就相当于把参数传递给了了call调用的c函数

        mov 0x8(%ebp), %eax
    
    或者可以不用把%esp传递给%ebp，那么也就不用保存上一个%ebp，直接使用相对%esp的偏移量传递值给%eax

	    mov 0x4(%esp), %eax

    最后将%eax压入栈，调用c函数，完成c函数读取栈顶值作为参数，完成参数传递

        push %eax
	    call kernel_init


    这段汇编的作用是使用_start指定入口地址以及方便手动传递参数

    
## 内核总览

我们在内核初始化函数中初始化内核的各项功能，这些功能代码构成了内核状态的一部分

* 内核构成

    一个内核由以下几部分组成：cpu管理、进程管理、存储管理、文件系统、系统调用

    初始化内核就是初始化这些组成部分

    在初始化之前，我们传入了内存检测结果，这个结果将在很大程度上影响我们的操作系统运行，因此我们对其做一个断言，如果后续问题是内存检测导致的，我们将快速定位到错误原因

        void kernel_init(boot_info_t * boot_info)
        {
            //断定它成立，如果不成立在此处引发异常并中断程序
            ASSERT(boot_info->ram_region_count != 0);
    
            cpu_init();
            //日志初始化放在前面，后面调用的函数就能使用日志打印错误信息
            log_init();
            irq_init();
            time_init();
            task_manager_init();
        }


* 内存结构总览

    ![avatar](/source/markdown_img/1/1.png)



* 快速跳转

    [OS实验日志2.1-cpu初始化](https://bandaobd.github.io/2023/04/23/OS实验日志2.1-cpu初始化/)

    [OS实验日志2.2-中断和异常](https://bandaobd.github.io/2023/04/23/OS实验日志2.2-中断和异常/)

    [OS实验日志2.3-打印日志](https://bandaobd.github.io/2023/04/23/OS实验日志2.3-打印日志/)

    [OS实验日志2.4-TSS结构和简单的双任务切换](https://bandaobd.github.io/2023/04/23/OS实验日志2.4-TSS结构和简单的双任务切换/)

    [OS实验日志2.5-进程调度算法](https://bandaobd.github.io/2023/04/23/OS实验日志2.5-进程调度算法/)

    [OS实验日志2.6-内存管理与虚拟内存](https://bandaobd.github.io/2023/04/23/OS实验日志2.6-内存管理与虚拟内存/)

    [OS实验日志2.7-系统调用实现](https://bandaobd.github.io/2023/04/23/OS实验日志2.7-系统调用实现/)

    [OS实验日志2.8-文件系统](https://bandaobd.github.io/2023/04/23/OS实验日志2.8-文件系统/)




## 一些硬件和机制总览

*这里只是简要介绍一下各部分功能和部分实现，具体实现见上面的跳转链接*

*个人理解，不一定对*

*还没做完，后面会加新做的部分*


### 地址分段机制
1. 分段机制是设置逻辑地址结构的方法
2. 逻辑地址描述为：段号：偏移量
3. 使用GDT表结构设置程序的段号，段号保存在GDT表的表项中
4. 每个表项除了段号，还有相应位用于的代码和数据保护机制
5. 有多种类型的表项代表不同类型的段：数据、代码、栈、门、tss，它们的结构也各不相同，分段机制隔离了这些代码和数据
6. 逻辑地址是程序员可见的地址，进程的运行离不开GDT表，GDT表是描述逻辑地址的结构

### 分页机制
1. 分页机制与分段机制不同，后者是设置逻辑地址结构的方法，而分页机制是实现虚拟地址和物理地址映射的方法，在平坦模型下逻辑地址可看作等同于虚拟地址
2. 虚拟地址的来源是cpu的总线，因此是程序员不可见的
3. 上面说到，虚拟地址来源于cpu地址总线，因此其大小也由总线位数决定，比如32位总线的cpu的寻址范围为 2^32 也就是 4 * 1024 * 1024 * 1024 = 4GB，由此可知虚拟地址的作用之一是地址扩展，然而一台电脑上加载的代码数量上限一定程度上取决于实际物理内存的大小，如果物理地址的范围小于总线寻址范围，那么虚拟内存中被填满的部分一定小于物理内存
3. 虚拟内存也能实现内核代码数据保护、进程数据隔离和共享、进程权限设置等功能
3. 虚拟地址和物理地址的映射函数由操作系统决定，映射的结果保存在多级页表结构中

### 物理地址
1. 物理地址就是物理地址，磁盘和硬盘内的物理地址是如何组织和寻址的请自行查阅资料
2. 知道的少量信息是linux上的物理地址一般被分为大小为4kb的页，即使一个进程大小不满4kb，下一个进程也不会被加载到这4kb中紧随着这个进程的位置，而是选择下一块4kb页，因此虚拟地址和物理地址做映射时需要考虑4kb地址对齐的问题

### 段寄存器
1. 段寄存器其中存放段选择子，决定选择GDT表中的段描述符，选择子包含段描述符的起始地址和大小，还有属性，属性中包括存在标志位和RPL权限，描述符包含代码区的起始地址、大小和属性等

        CS
        代码段，指定代码段空间
        SS
        栈段，指定栈的空间，访问时使用SS:ESP
        DS
        ES
        FS
        GS
        以上是数据段，指定数据段的控制

    寄存器中的选择子结构:

        0~1 权限位RPL，2~2 TI 到GDT表或LDT表，3~15 Index索引



### 带保护的平坦模式
既然上面提到了逻辑地址是面向操作系统使用者的，而平坦模型又是一种逻辑地址模型，因此我们需要对操作系统使用者做一些限制保护内核安全

1. 首先是基础平坦模式：

    分为代码段和数据段，两个段起始地址都为0，大小为4GB，CS指向代码区，其它指向数据段，基地址都是0

2. 保护平坦模式

    相比于上面，数据区加了个limit界限防止恶意数据溢出修改代码段
    我们选用这种保护平坦模式

3. 平坦模式中做的保护有限，我们会在其他地址模型中做其他的保护，这些保护组合在一起构成了我们整个操作系统的保护

### 寻址过程

逻辑地址（GDT）->线性地址->虚拟地址（查页表）->物理地址

我们采用平坦模型，线性地址等于逻辑地址

1. 逻辑地址寻址：
    寄存器段选择子->GDT表段描述符（基地址）+offset->逻辑地址

    例如

        逻辑地址0x8:0x1234
        用0x8查到GDT表中基地址为0x10000
        线性地址为0x10000+0x1234 = 0x11234

2. 虚拟地址寻址














### 如何控制物理地址
对于内核代码编写者来说，我们需要并且能够控制物理地址

通过控制ELF？










6. 添加assert宏辅助调试
见注释
如果要变成发布版，在最外层CMakeList.txt中的CMAKE_C_FLAGS中添加-DRELEASE即可
































# 从这里开始与前置课分离，每天学的内容必须立刻整理并写成markdown发布，前面的可以选择慢慢整理，问题不大




